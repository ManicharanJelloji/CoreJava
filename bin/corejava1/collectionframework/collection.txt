Collection<E>
public interface Collection<E> extends Iterable<E> 
int size();
boolea{n isEmpty();
boolean contains(Object o);
Iterator<E> iterator();
Object[] toArray();
<T> T[] toArray(T[] a);
boolean add(E e);
boolean remove(Object o);
boolean containsAll(Collection<?> c);
boolean addAll(Collection<? extends E> c);
boolean removeAll(Collection<?> c);
boolean retainAll(Collection<?> c);
void clear();
boolean equals(Object o);
int hashCode();

//All this are Abstract/Unimplemented methods there are few default methods in the collection interface
================================
AbstractCollection<E>
public abstract class AbstractCollection<E> implements Collection<E> 
iterator();
size();
//All the methods we see in the collection interface are Abstract/unimplemented methods.
//As abstractCollection implements collection all the unimplemeted methods are implemented in AbstractCollection.
================================
List<E>
public interface List<E> extends Collection<E> 
int size();
boolean isEmpty();
boolean contains(Object o);
Iterator<E> iterator();
Object[] toArray();
<T> T[] toArray(T[] a);
boolean add(E e);
boolean remove(Object o);
boolean containsAll(Collection<?> c);
boolean addAll(Collection<? extends E> c);
boolean addAll(int index, Collection<? extends E> c);
boolean removeAll(Collection<?> c);
boolean retainAll(Collection<?> c);
void clear();
boolean equals(Object o);
int hashCode();
E get(int index);
E set(int index, E element);
void add(int index, E element);
E remove(int index);
int indexOf(Object o);
int lastIndexOf(Object o);
ListIterator<E> listIterator();
ListIterator<E> listIterator(int index);
List<E> subList(int fromIndex, int toIndex);

//All this are Abstract/unimplemented methods in the List interface but there are few default and static methods in the List Interface too.

//All the methods we see above are the Abstract/Unimplemented methods.
//We see that almost all this methods are available in the Collection Interface too and List Interface extends 
//collection Interface i.e, if any method is not available int the List Interface it will check in the Collection Interface as List extends Collection.
==============================================
AbstractList<E>
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>

//so if we see here AbstractList is extending from AbstractCollection(i.e, If any method we want is not available in the AbstractList then we can use the one 
//which is available in the AbstractCollection as they are extended). Also the AbtractList Implements List(I.e, All the abstract/Unimplemented methods are implemented over here)


==============================================
Set<E>
public interface Set<E> extends Collection<E> 

//Set extends Collection(i.e, if any method is not available in set then we can extend it from collection)

int size();
boolean isEmpty();
boolean contains(Object o);
Iterator<E> iterator();
Object[] toArray();
<T> T[] toArray(T[] a);
boolean add(E e);
boolean remove(Object o);
boolean containsAll(Collection<?> c);
boolean addAll(Collection<? extends E> c);
boolean retainAll(Collection<?> c);
boolean removeAll(Collection<?> c);
void clear();
boolean equals(Object o);
int hashCode();

//if we observe carefully all the abstract method which are available in collections are also available int sets expect some default and static methods.
===============================================
AbstractSet<E>
public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E> 

//As AbstractSet is Extending AbstarctCollection so almost all the methods are not implemented in the AbstractSet class as they are same method implementing them again 
//is waste of memory(I think). But this three methods are implemented in AbstractSet.

public boolean equals(Object o)
public int hashCode() {
public boolean removeAll(Collection<?> c)


====================================
SortedSet<E>
public interface SortedSet<E> extends Set<E> 

//SortedSet extends Set, so all the methods available in Set Interface can be used in SortedSet.

Comparator<? super E> comparator();
SortedSet<E> subSet(E fromElement, E toElement);
SortedSet<E> headSet(E toElement);
SortedSet<E> tailSet(E fromElement);
E first();
E last();

//All this are abstract/unimplemented methods available in the SortedSet.
================================
NavigableSet<E>
public interface NavigableSet<E> extends SortedSet<E> 

//NavigableSet Extends SortedSet, so all the methods available in the SortedSet can be used in NavigableSet
E lower(E e); <
E floor(E e); <= or <
E ceiling(E e); >= or >
E higher(E e); >
E pollFirst();
E pollLast();
Iterator<E> iterator();
NavigableSet<E> descendingSet();
Iterator<E> descendingIterator();
NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement,   boolean toInclusive);
NavigableSet<E> headSet(E toElement, boolean inclusive);
NavigableSet<E> tailSet(E fromElement, boolean inclusive);

SortedSet<E> subSet(E fromElement, E toElement);
SortedSet<E> headSet(E toElement);
SortedSet<E> tailSet(E fromElement);
==================================================
Queue<E> "FIFO"
public interface Queue<E> extends Collection<E>

//As its extending collection we can access all the methods which are available in Collection interface.

boolean add(E e);
boolean offer(E e);
E remove();
E poll();
E element();
E peek();

//All this are Abstract/unimplemented methods
================================================
AbstractQueue<E>
public abstract class AbstractQueue<E> extends AbstractCollection<E> implements Queue<E> {

//So here AbstractQueue extends AbstractCollections
//And AbstractQueue Implements Queue


=======================
Deque<E> "double ended queue" "Both FIFO and LIFO"
public interface Deque<E> extends Queue<E> 

//Here Deque extends queue. so all the methods available in queue can be used in Deque.

void addFirst(E e);
void addLast(E e);
boolean offerFirst(E e);
boolean offerLast(E e);
E removeFirst();
E removeLast();
E pollFirst();
E pollLast();
E getFirst();
E getLast();
E peekFirst();
E peekLast();
boolean removeFirstOccurrence(Object o);
boolean removeLastOccurrence(Object o);

//As its a double end queue it also do queue operation, so there are discussing them again.

boolean add(E e);
boolean offer(E e);
E remove();
E poll();
E element();
E peek();
boolean addAll(Collection<? extends E> c);
void push(E e);
E pop();
boolean remove(Object o);
boolean contains(Object o);
int size();
Iterator<E> iterator();
Iterator<E> descendingIterator();

===========================
//All this abstract/unimplemented methods are implemented in a class-ArrayDeque.




==========================
Map<K, V>
public interface Map<K, V> 

int size();
boolean isEmpty();
boolean containsKey(Object key);
boolean containsValue(Object value);
V get(Object key);
V put(K key, V value);
V remove(Object key);
void putAll(Map<? extends K, ? extends V> m);
void clear();
Set<K> keySet();
Collection<V> values();
Set<Map.Entry<K, V>> entrySet();
=================================
Entry<K, V>
interface Entry<K, V>

K getKey();
V getValue();
V setValue(V value);
boolean equals(Object o);
int hashCode();
=====================================
SortedMap<K,V>
public interface SortedMap<K,V> extends Map<K,V> {


Comparator<? super K> comparator();
SortedMap<K,V> subMap(K fromKey, K toKey);
SortedMap<K,V> headMap(K toKey);
SortedMap<K,V> tailMap(K fromKey);
K firstKey();
K lastKey();
Set<K> keySet();
Collection<V> values();
Set<Map.Entry<K, V>> entrySet();
======================================
NavigableMap<K,V>
public interface NavigableMap<K,V> extends SortedMap<K,V> {

Map.Entry<K,V> lowerEntry(K key);
K lowerKey(K key);
Map.Entry<K,V> floorEntry(K key);
K floorKey(K key);
Map.Entry<K,V> ceilingEntry(K key);
K ceilingKey(K key);
Map.Entry<K,V> higherEntry(K key);
K higherKey(K key);
Map.Entry<K,V> firstEntry();
Map.Entry<K,V> lastEntry();
Map.Entry<K,V> pollFirstEntry();
Map.Entry<K,V> pollLastEntry();
NavigableMap<K,V> descendingMap();
NavigableSet<K> navigableKeySet();
NavigableSet<K> descendingKeySet();
NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,
                             K toKey,   boolean toInclusive);
NavigableMap<K,V> headMap(K toKey, boolean inclusive);                 
NavigableMap<K,V> tailMap(K fromKey, boolean inclusive);
SortedMap<K,V> subMap(K fromKey, K toKey);
SortedMap<K,V> headMap(K toKey);                           
SortedMap<K,V> tailMap(K fromKey);




























